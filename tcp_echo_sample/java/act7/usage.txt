USE AT YOUR OWN RISK!!

【サーバー側】
$ java Server <port> <charset> <read_timeout> <record_size>

- <port> : サーバー側のsocketのbindポート番号
- <charset> : ソケットで送受信する文字コード
- <read_timeout> : select(2)でのタイムアウト秒数（ミリ秒）
- <record_size> : echoする受信バイト数(ここで指定したバイト数分受信すると、echo送信する)

Ctrl-Cで終了します。

例：SJISの時
$ java Server 8080 Shift_JIS 10000 5
→8080番でBIND、タイムアウトは10秒、5バイト受信した時点でその分echo送信。

例：EBCDICの時
$ java Server 8080 x-IBM930 10000 5
or
$ java Server 8080 x-IBM939 10000 5

※EBCDICについてはIBMの規定する以下のコードが使用可能。
x-IBM930 : IBM EBCDIC 日本語拡張カタカナ
x-IBM939 : IBM EBCDIC 日本語拡張ローマ字
(http://ja.wikipedia.org/wiki/EBCDIC)

→富士通のJEFなどでのJIS漢字などは使用不可能と思われる。

【クライアント側】
$ java Client <remote_host> <remote_port> <local_port> <charset> <record_size> <file> <interval in millis>

- <remote_host> : 接続先のIPアドレス or ホスト名
- <remote_port> : 接続先のポート番号
- <local_port> : クライアント側のbind(2)用ポート番号
　　※<local_post>に0を指定すると、OS側のデフォルト：bind(2)を呼ばない。
　　※一応Socket#setReuseAddress(true)を呼び、SO_REUSEADDR ソケットオプションを有効にしているはずだがWinXP上では効いてない？
- <charset> : ソケットで送受信する文字コード
- <record_size> : 送信レコードサイズ
- <file> : 送信データファイル
- <interval in millis> : データ送信間隔秒数（ミリ秒）

Ctrl-Cか、送信データファイルを全て処理できれば終了します。

例：SJISの場合
$ java Client 192.168.250.50 8080 8081 Shift_JIS 5 testdata.txt 1000

サーバー：192.168.250.50, 8080番
クライアント：8081番

[testdata.txt]
---------------------------------------
#ああああ
12345

abcd
   
abcdef
---------------------------------------
※"#"で始まる行、半角空白だけの行、空行は無視されます。

→次の順番で送信されます。
"12345"
" abcd"
"abcde"

※レコードサイズを"5"に指定している為、
→ " abcd" : それに満たない場合は頭空白埋め右寄せで補正されて送信されます。
→ "abcde" : レコードサイズを超える場合は、超過部分を切り捨てて送信されます。

【標準出力例：サーバー側】 ※"[(クライアント側)]->[(サーバー側)],<(JavaのThreadID)>,YYYY-MM-DD HH:MM:SS(システムミリ秒)"

ワンポイント：teeコマンドを組み合わせると、標準出力をファイルとコンソールの両方に流し込めます。
下の例だと、コンソールと"log.txt"の両方に同じ内容が出力されます。

[msakamoto@basara echoes]$ java Server 8080 x-IBM930 10000 5 | tee log.txt
[:0]->[:0],<1>,2008-09-09 07:08:16(1221019696664),サーバー側ソケットチャネルをopenしました。
[:0]->[0.0.0.0:8080],<1>,2008-09-09 07:08:16(1221019696695),サーバー側ソケットチャネルをポート番号[8080]にbindしました。
[:0]->[0.0.0.0:8080],<1>,2008-09-09 07:08:16(1221019696701),サーバー側ソケットチャネルをNON-BLOCKINGに設定しました。
[:0]->[0.0.0.0:8080],<1>,2008-09-09 07:08:16(1221019696705),サーバー側ソケットチャネルをSelectorに登録しました。
[:0]->[0.0.0.0:8080],<1>,2008-09-09 07:08:19(1221019699211),サーバー側ソケットチャネルでaccept()が発生しました。
[192.168.250.100:2712]->[192.168.250.50:8080],<1>,2008-09-09 07:08:19(1221019699221),クライアントソケットチャネルを取得しました。
[192.168.250.100:2712]->[192.168.250.50:8080],<7>,2008-09-09 07:08:19(1221019699260),クライアントスレッドを開始します。
[192.168.250.100:2712]->[192.168.250.50:8080],<7>,2008-09-09 07:08:19(1221019699264),クライアントソケットチャネルをNON-BLOCKINGに設定しました。
[192.168.250.100:2712]->[192.168.250.50:8080],<7>,2008-09-09 07:08:19(1221019699266),クライアントソケットチャネルをSelectorに登録しました。
[192.168.250.100:2712]->[192.168.250.50:8080],<7>,2008-09-09 07:08:19(1221019699268),クライアントソケットチャネルの処理を開始します。
[192.168.250.100:2712]->[192.168.250.50:8080],<7>,2008-09-09 07:08:19(1221019699277),クライアントソケットチャネルより[5]バイトreadされました。
[192.168.250.100:2712]->[192.168.250.50:8080],<7>,2008-09-09 07:08:19(1221019699282),RECV:RAW=[ 0xF1 0xF2 0xF3 0xF4 0xF5]
[192.168.250.100:2712]->[192.168.250.50:8080],<7>,2008-09-09 07:08:19(1221019699287),RECV:DECODED=[12345]
[192.168.250.100:2712]->[192.168.250.50:8080],<7>,2008-09-09 07:08:19(1221019699292),SEND:DECODED=[100045]
[192.168.250.100:2712]->[192.168.250.50:8080],<7>,2008-09-09 07:08:19(1221019699297),SEND:RAW=[ 0xF1 0xF0 0xF0 0xF0 0xF4 0xF5]
[192.168.250.100:2712]->[192.168.250.50:8080],<7>,2008-09-09 07:08:20(1221019700309),クライアントソケットチャネルの処理を開始します。
[192.168.250.100:2712]->[192.168.250.50:8080],<7>,2008-09-09 07:08:20(1221019700317),クライアントソケットチャネルより[5]バイトreadされました。
[192.168.250.100:2712]->[192.168.250.50:8080],<7>,2008-09-09 07:08:20(1221019700318),RECV:RAW=[ 0x40 0x62 0x63 0x64 0x65]
[192.168.250.100:2712]->[192.168.250.50:8080],<7>,2008-09-09 07:08:20(1221019700320),RECV:DECODED=[ abcd]
[192.168.250.100:2712]->[192.168.250.50:8080],<7>,2008-09-09 07:08:20(1221019700323),SEND:DECODED=[ 000cd]
[192.168.250.100:2712]->[192.168.250.50:8080],<7>,2008-09-09 07:08:20(1221019700326),SEND:RAW=[ 0x40 0xF0 0xF0 0xF0 0x64 0x65]
[192.168.250.100:2712]->[192.168.250.50:8080],<7>,2008-09-09 07:08:21(1221019701337),クライアントソケットチャネルの処理を開始します。
[192.168.250.100:2712]->[192.168.250.50:8080],<7>,2008-09-09 07:08:21(1221019701338),クライアントソケットチャネルより[5]バイトreadされました。
[192.168.250.100:2712]->[192.168.250.50:8080],<7>,2008-09-09 07:08:21(1221019701356),RECV:RAW=[ 0x62 0x63 0x64 0x65 0x66]
[192.168.250.100:2712]->[192.168.250.50:8080],<7>,2008-09-09 07:08:21(1221019701358),RECV:DECODED=[abcde]
[192.168.250.100:2712]->[192.168.250.50:8080],<7>,2008-09-09 07:08:21(1221019701359),SEND:DECODED=[a000de]
[192.168.250.100:2712]->[192.168.250.50:8080],<7>,2008-09-09 07:08:21(1221019701361),SEND:RAW=[ 0x62 0xF0 0xF0 0xF0 0x65 0x66]
[192.168.250.100:2712]->[192.168.250.50:8080],<7>,2008-09-09 07:08:22(1221019702369),クライアントソケットチャネルの処理を開始します。
[192.168.250.100:2712]->[192.168.250.50:8080],<7>,2008-09-09 07:08:22(1221019702371),クライアントソケットチャネルより[-1]バイトreadされました。
[192.168.250.100:2712]->[192.168.250.50:8080],<7>,2008-09-09 07:08:22(1221019702372),クライアントソケットチャネルを切断します。
[:0]->[:0],<7>,2008-09-09 07:08:22(1221019702390),クライアントソケットがcloseされました。セレクタをcloseしました。
^C[msakamoto@basara echoes]$

【標準出力例：クライアント側】 ※"[(サーバー側)]->[(クライアント側)],<(JavaのThreadID)>,YYYY-MM-DD HH:MM:SS(システムミリ秒)"

C:\in_vitro\eclipse.workspaces\in_vitro\echoes>java Client 192.168.250.50 8080 0 x-IBM930 5 testdata.txt 1000
[:0]->[:0],<1>,2008-09-09 07:09:18(1220954958203),データファイル[testdata.txt], 全行数[7]/有効行数[3] ロード完了
[192.168.250.50:8080]->[192.168.250.100:2712],<1>,2008-09-09 07:09:18(1220954958234),[1/3],SEND:DECODED=[12345]
[192.168.250.50:8080]->[192.168.250.100:2712],<1>,2008-09-09 07:09:18(1220954958234),[1/3],SEND:RAW=[ 0xF1 0xF2 0xF3 0xF4 0xF5]
[192.168.250.50:8080]->[192.168.250.100:2712],<1>,2008-09-09 07:09:18(1220954958312),[1/3],RECV:RAW=[ 0xF1 0xF0 0xF0 0xF0 0xF4 0xF5]
[192.168.250.50:8080]->[192.168.250.100:2712],<1>,2008-09-09 07:09:18(1220954958312),[1/3],RECV:DECODED=[100045]
[192.168.250.50:8080]->[192.168.250.100:2712],<1>,2008-09-09 07:09:18(1220954958312),[1/3],...completed, sleep [1000] milli seconds...
[192.168.250.50:8080]->[192.168.250.100:2712],<1>,2008-09-09 07:09:19(1220954959312),[2/3],SEND:DECODED=[ abcd]
[192.168.250.50:8080]->[192.168.250.100:2712],<1>,2008-09-09 07:09:19(1220954959328),[2/3],SEND:RAW=[ 0x40 0x62 0x63 0x64 0x65]
[192.168.250.50:8080]->[192.168.250.100:2712],<1>,2008-09-09 07:09:19(1220954959343),[2/3],RECV:RAW=[ 0x40 0xF0 0xF0 0xF0 0x64 0x65]
[192.168.250.50:8080]->[192.168.250.100:2712],<1>,2008-09-09 07:09:19(1220954959343),[2/3],RECV:DECODED=[ 000cd]
[192.168.250.50:8080]->[192.168.250.100:2712],<1>,2008-09-09 07:09:19(1220954959343),[2/3],...completed, sleep [1000] milli seconds...
[192.168.250.50:8080]->[192.168.250.100:2712],<1>,2008-09-09 07:09:20(1220954960343),[3/3],SEND:DECODED=[abcde]
[192.168.250.50:8080]->[192.168.250.100:2712],<1>,2008-09-09 07:09:20(1220954960343),[3/3],SEND:RAW=[ 0x62 0x63 0x64 0x65 0x66]
[192.168.250.50:8080]->[192.168.250.100:2712],<1>,2008-09-09 07:09:20(1220954960375),[3/3],RECV:RAW=[ 0x62 0xF0 0xF0 0xF0 0x65 0x66]
[192.168.250.50:8080]->[192.168.250.100:2712],<1>,2008-09-09 07:09:20(1220954960375),[3/3],RECV:DECODED=[a000de]
[192.168.250.50:8080]->[192.168.250.100:2712],<1>,2008-09-09 07:09:20(1220954960375),[3/3],...completed, sleep [1000] milli seconds...

【サーバー側でechoするデータを操作するには？】

→ Worker.java中の String fabricateResponseData(String source) メソッドをカスタマイズしてください。

"String source" 引数にはJava用に変換済の受信文字列が渡されてきます。
例えば次のようにすると、受信文字列の2-3文字目を "000" という文字列に置換します。
（この例ですと送信文字数が1文字増えちゃいますので、実際は適当に調整して下さい。）

String fabricateResponseData(String source)
{
	StringBuffer sb = new StringBuffer(source);
	
	// http://java.sun.com/j2se/1.5.0/ja/docs/ja/api/java/lang/StringBuffer.html
	int start = 1; // 開始インデックス (この値を含む)
	int end = 3; // 終了インデックス (この値を含まない) 
    String str = "000"; // 以前の内容を置換する新しい文字列
    sb.replace(start, end, str);
	
	return sb.toString();
}

【コンパイル方法】

Eclipse上で作っていましたが、特に外部ライブラリも使っていない為、普通に以下のようにコンパイルできると思います。

DOS> javac Worker.java

ソースコードの文字コードはSJISになっているため、Solaris上でコンパイルする場合は"-encoding"オプションが必要だと思います。

$ javac -encoding Windows-31J Worker.java

【主要ファイル構成】
- Server.java : サーバー側のメイン(accept(2)実行)クラス
- Worker.java : サーバー側のソケット処理クラス(accept(2)で取得したsocketをNON-BLOCKINGでselect(2)する)
- Client.java : クライアント側のメインクラス
- Logger.java : コンソール出力用のログメソッドや、ユーティリティメソッドをまとめたクラス
(- .classpath, .project : Eclipseの使用しているファイル)


